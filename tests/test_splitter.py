# Test generated by AI
import unittest
from unittest.mock import Mock, patch, MagicMock
from pathlib import Path
from tempfile import NamedTemporaryFile
import io
from src.chevelle.core.splitter import Splitter, Track, Disc


class TestTrack(unittest.TestCase):
    """Test suite for the Track dataclass."""

    def test_track_creation_valid(self):
        """Test creating a valid Track object."""
        track = Track(Path("test.mp3"), "Test Song", 180.5)
        self.assertEqual(track.path, Path("test.mp3"))
        self.assertEqual(track.title, "Test Song")
        self.assertEqual(track.duration, 180.5)

    def test_track_validation_invalid_path_type(self):
        """Test that Track raises TypeError for non-Path path."""
        with self.assertRaises(TypeError) as context:
            Track("not_a_path", "Test", 100)
        self.assertIn("path must be a Path object", str(context.exception))

    def test_track_validation_invalid_title_type(self):
        """Test that Track raises TypeError for non-string title."""
        with self.assertRaises(TypeError) as context:
            Track(Path("test.mp3"), 123, 100)
        self.assertIn("title must be a string", str(context.exception))

    def test_track_validation_invalid_duration_type(self):
        """Test that Track raises TypeError for non-numeric duration."""
        with self.assertRaises(TypeError) as context:
            Track(Path("test.mp3"), "Test", "not_a_number")
        self.assertIn("duration must be a number", str(context.exception))

    def test_track_validation_negative_duration(self):
        """Test that Track raises ValueError for negative duration."""
        with self.assertRaises(ValueError) as context:
            Track(Path("test.mp3"), "Test", -10.5)
        self.assertIn("duration must be non-negative", str(context.exception))

    def test_track_zero_duration(self):
        """Test that Track accepts zero duration."""
        track = Track(Path("test.mp3"), "Silence", 0)
        self.assertEqual(track.duration, 0)

    def test_track_integer_duration(self):
        """Test that Track accepts integer duration."""
        track = Track(Path("test.mp3"), "Test", 120)
        self.assertEqual(track.duration, 120)


class TestDisc(unittest.TestCase):
    """Test suite for the Disc dataclass."""

    def test_disc_creation_valid(self):
        """Test creating a valid Disc object."""
        disc = Disc(id=1)
        self.assertEqual(disc.id, 1)
        self.assertEqual(disc.tracks, [])

    def test_disc_with_tracks(self):
        """Test creating a Disc with initial tracks."""
        tracks = [
            Track(Path("t1.mp3"), "Track 1", 180),
            Track(Path("t2.mp3"), "Track 2", 200)
        ]
        disc = Disc(id=2, tracks=tracks)
        self.assertEqual(len(disc.tracks), 2)
        self.assertEqual(disc.total_seconds, 380)

    def test_disc_validation_invalid_id_type(self):
        """Test that Disc raises TypeError for non-integer id."""
        with self.assertRaises(TypeError) as context:
            Disc(id="1")
        self.assertIn("id must be an integer", str(context.exception))

    def test_disc_validation_invalid_id_value(self):
        """Test that Disc raises ValueError for non-positive id."""
        with self.assertRaises(ValueError) as context:
            Disc(id=0)
        self.assertIn("id must be positive", str(context.exception))

    def test_disc_validation_negative_id(self):
        """Test that Disc raises ValueError for negative id."""
        with self.assertRaises(ValueError) as context:
            Disc(id=-5)
        self.assertIn("id must be positive", str(context.exception))

    def test_disc_validation_invalid_tracks_type(self):
        """Test that Disc raises TypeError for non-list tracks."""
        with self.assertRaises(TypeError) as context:
            Disc(id=1, tracks="not_a_list")
        self.assertIn("tracks must be a list", str(context.exception))

    def test_disc_validation_invalid_track_objects(self):
        """Test that Disc raises TypeError for non-Track objects in tracks."""
        with self.assertRaises(TypeError) as context:
            Disc(id=1, tracks=["not", "tracks"])
        self.assertIn("All tracks must be Track objects", str(context.exception))

    def test_disc_total_seconds_empty(self):
        """Test total_seconds property with no tracks."""
        disc = Disc(id=1)
        self.assertEqual(disc.total_seconds, 0)

    def test_disc_total_seconds_multiple_tracks(self):
        """Test total_seconds property with multiple tracks."""
        tracks = [
            Track(Path("t1.mp3"), "Track 1", 120.5),
            Track(Path("t2.mp3"), "Track 2", 180.3),
            Track(Path("t3.mp3"), "Track 3", 200.2)
        ]
        disc = Disc(id=1, tracks=tracks)
        self.assertAlmostEqual(disc.total_seconds, 501.0, places=1)


class TestSplitterInitialization(unittest.TestCase):
    """Test suite for Splitter initialization."""

    def test_splitter_default_capacity(self):
        """Test Splitter with default capacity."""
        splitter = Splitter()
        self.assertEqual(splitter.limit_seconds, 79.5 * 60)

    def test_splitter_custom_capacity(self):
        """Test Splitter with custom capacity."""
        splitter = Splitter(capacity_minutes=80.0)
        self.assertEqual(splitter.limit_seconds, 80.0 * 60)

    def test_splitter_validation_invalid_type(self):
        """Test that Splitter raises TypeError for non-numeric capacity."""
        with self.assertRaises(TypeError) as context:
            Splitter(capacity_minutes="80")
        self.assertIn("capacity_minutes must be a number", str(context.exception))

    def test_splitter_validation_zero_capacity(self):
        """Test that Splitter raises ValueError for zero capacity."""
        with self.assertRaises(ValueError) as context:
            Splitter(capacity_minutes=0)
        self.assertIn("capacity_minutes must be positive", str(context.exception))

    def test_splitter_validation_negative_capacity(self):
        """Test that Splitter raises ValueError for negative capacity."""
        with self.assertRaises(ValueError) as context:
            Splitter(capacity_minutes=-10)
        self.assertIn("capacity_minutes must be positive", str(context.exception))

    def test_splitter_integer_capacity(self):
        """Test Splitter accepts integer capacity."""
        splitter = Splitter(capacity_minutes=80)
        self.assertEqual(splitter.limit_seconds, 80 * 60)


class TestLoadTracks(unittest.TestCase):
    """Test suite for load_tracks method."""

    def test_load_tracks_invalid_input_type(self):
        """Test that load_tracks raises TypeError for non-list input."""
        splitter = Splitter()
        with self.assertRaises(TypeError) as context:
            splitter.load_tracks("not_a_list")
        self.assertIn("paths must be a list", str(context.exception))

    @patch('sys.stdout', new_callable=io.StringIO)
    def test_load_tracks_non_path_objects(self, mock_stdout):
        """Test that load_tracks handles non-Path objects gracefully."""
        splitter = Splitter()
        result = splitter.load_tracks(["string_path", 123, Path("test.mp3")])
        output = mock_stdout.getvalue()
        self.assertIn("WARNING: Skipping non-Path object", output)
        self.assertEqual(len(result), 0)  # No valid files loaded

    @patch('sys.stdout', new_callable=io.StringIO)
    def test_load_tracks_nonexistent_file(self, mock_stdout):
        """Test that load_tracks handles non-existent files."""
        splitter = Splitter()
        result = splitter.load_tracks([Path("/nonexistent/file.mp3")])
        output = mock_stdout.getvalue()
        self.assertIn("WARNING: File does not exist", output)
        self.assertEqual(len(result), 0)

    @patch('sys.stdout', new_callable=io.StringIO)
    def test_load_tracks_directory_instead_of_file(self, mock_stdout):
        """Test that load_tracks handles directories."""
        splitter = Splitter()
        result = splitter.load_tracks([Path(".")])
        output = mock_stdout.getvalue()
        self.assertIn("WARNING: Not a file", output)
        self.assertEqual(len(result), 0)

    @patch('src.chevelle.core.splitter.MP3')
    def test_load_tracks_successful(self, mock_mp3):
        """Test successful track loading."""
        # Create a mock MP3 object
        mock_audio = MagicMock()
        mock_audio.info.length = 180.5
        mock_mp3.return_value = mock_audio

        # Create a temporary file
        with NamedTemporaryFile(suffix='.mp3', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            splitter = Splitter()
            result = splitter.load_tracks([tmp_path])
            
            self.assertEqual(len(result), 1)
            self.assertEqual(result[0].path, tmp_path)
            self.assertEqual(result[0].title, tmp_path.stem)
            self.assertEqual(result[0].duration, 180.5)
        finally:
            tmp_path.unlink()

    @patch('sys.stdout', new_callable=io.StringIO)
    @patch('src.chevelle.core.splitter.MP3')
    def test_load_tracks_mp3_without_info(self, mock_mp3, mock_stdout):
        """Test handling of MP3 files without proper info attribute."""
        mock_audio = MagicMock()
        del mock_audio.info
        mock_mp3.return_value = mock_audio

        with NamedTemporaryFile(suffix='.mp3', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            splitter = Splitter()
            result = splitter.load_tracks([tmp_path])
            output = mock_stdout.getvalue()
            
            self.assertIn("WARNING: Could not read duration", output)
            self.assertEqual(len(result), 0)
        finally:
            tmp_path.unlink()

    @patch('sys.stdout', new_callable=io.StringIO)
    @patch('src.chevelle.core.splitter.MP3')
    def test_load_tracks_mp3_exception(self, mock_mp3, mock_stdout):
        """Test handling of exceptions during MP3 loading."""
        mock_mp3.side_effect = Exception("Corrupted file")

        with NamedTemporaryFile(suffix='.mp3', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            splitter = Splitter()
            result = splitter.load_tracks([tmp_path])
            output = mock_stdout.getvalue()
            
            self.assertIn("WARNING: Error reading", output)
            self.assertIn("Corrupted file", output)
            self.assertEqual(len(result), 0)
        finally:
            tmp_path.unlink()


class TestSplitIntoDiscs(unittest.TestCase):
    """Test suite for split_into_discs method (Greedy algorithm)."""

    def test_split_empty_list(self):
        """Test splitting an empty track list."""
        splitter = Splitter()
        result = splitter.split_into_discs([])
        self.assertEqual(result, [])

    def test_split_invalid_input_type(self):
        """Test that split_into_discs raises TypeError for non-list input."""
        splitter = Splitter()
        with self.assertRaises(TypeError) as context:
            splitter.split_into_discs("not_a_list")
        self.assertIn("tracks must be a list", str(context.exception))

    def test_split_invalid_track_objects(self):
        """Test that split_into_discs raises TypeError for non-Track objects."""
        splitter = Splitter()
        with self.assertRaises(TypeError) as context:
            splitter.split_into_discs(["not", "tracks"])
        self.assertIn("All items must be Track objects", str(context.exception))

    def test_split_single_track_fits(self):
        """Test splitting with a single track that fits."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [Track(Path("t1.mp3"), "Track 1", 60 * 60)]  # 60 minutes
        
        result = splitter.split_into_discs(tracks)
        
        self.assertEqual(len(result), 1)
        self.assertEqual(len(result[0].tracks), 1)
        self.assertEqual(result[0].id, 1)

    def test_split_multiple_tracks_one_disc(self):
        """Test splitting multiple tracks that fit on one disc."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [
            Track(Path("t1.mp3"), "Track 1", 30 * 60),  # 30 min
            Track(Path("t2.mp3"), "Track 2", 25 * 60),  # 25 min
            Track(Path("t3.mp3"), "Track 3", 20 * 60),  # 20 min
        ]
        
        result = splitter.split_into_discs(tracks)
        
        self.assertEqual(len(result), 1)
        self.assertEqual(len(result[0].tracks), 3)
        self.assertAlmostEqual(result[0].total_seconds, 75 * 60, delta=1)

    def test_split_tracks_into_multiple_discs(self):
        """Test splitting tracks into multiple discs."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [
            Track(Path("t1.mp3"), "Track 1", 50 * 60),  # 50 min
            Track(Path("t2.mp3"), "Track 2", 40 * 60),  # 40 min
            Track(Path("t3.mp3"), "Track 3", 30 * 60),  # 30 min
        ]
        
        result = splitter.split_into_discs(tracks)
        
        self.assertEqual(len(result), 2)
        self.assertEqual(len(result[0].tracks), 1)  # 50 min
        self.assertEqual(len(result[1].tracks), 2)  # 40 + 30 = 70 min

    @patch('sys.stdout', new_callable=io.StringIO)
    def test_split_oversized_track(self, mock_stdout):
        """Test splitting with a track exceeding disc capacity."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [
            Track(Path("t1.mp3"), "Normal", 30 * 60),
            Track(Path("t2.mp3"), "Oversized", 90 * 60),  # Exceeds 80 min
            Track(Path("t3.mp3"), "Another", 20 * 60),
        ]
        
        result = splitter.split_into_discs(tracks)
        output = mock_stdout.getvalue()
        
        self.assertIn("WARNING: Track 'Oversized'", output)
        self.assertIn("exceeds disc capacity", output)
        self.assertEqual(len(result), 3)

    def test_split_preserves_order(self):
        """Test that greedy algorithm preserves track order."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [
            Track(Path("t1.mp3"), "Track 1", 50 * 60),
            Track(Path("t2.mp3"), "Track 2", 40 * 60),
            Track(Path("t3.mp3"), "Track 3", 10 * 60),
        ]
        
        result = splitter.split_into_discs(tracks)
        
        self.assertEqual(result[0].tracks[0].title, "Track 1")
        self.assertEqual(result[1].tracks[0].title, "Track 2")
        self.assertEqual(result[1].tracks[1].title, "Track 3")

    def test_split_disc_ids_sequential(self):
        """Test that disc IDs are sequential."""
        splitter = Splitter(capacity_minutes=40)
        tracks = [Track(Path(f"t{i}.mp3"), f"Track {i}", 30 * 60) for i in range(5)]
        
        result = splitter.split_into_discs(tracks)
        
        for i, disc in enumerate(result, start=1):
            self.assertEqual(disc.id, i)


class TestSplitIntoDiscsFillingGaps(unittest.TestCase):
    """Test suite for split_into_discs_filling_gaps method (Smart Fill algorithm)."""

    def test_smart_fill_empty_list(self):
        """Test smart fill with empty track list."""
        splitter = Splitter()
        result = splitter.split_into_discs_filling_gaps([])
        self.assertEqual(result, [])

    def test_smart_fill_invalid_input_type(self):
        """Test that smart fill raises TypeError for non-list input."""
        splitter = Splitter()
        with self.assertRaises(TypeError) as context:
            splitter.split_into_discs_filling_gaps("not_a_list")
        self.assertIn("tracks must be a list", str(context.exception))

    def test_smart_fill_invalid_track_objects(self):
        """Test that smart fill raises TypeError for non-Track objects."""
        splitter = Splitter()
        with self.assertRaises(TypeError) as context:
            splitter.split_into_discs_filling_gaps(["not", "tracks"])
        self.assertIn("All items must be Track objects", str(context.exception))

    def test_smart_fill_basic_gap_filling(self):
        """Test smart fill algorithm fills gaps correctly."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [
            Track(Path("t1.mp3"), "Music 50min", 50 * 60),  # 50 min
            Track(Path("t2.mp3"), "Music 40min", 40 * 60),  # 40 min (skipped)
            Track(Path("t3.mp3"), "Music 25min", 25 * 60),  # 25 min (fills gap)
            Track(Path("t4.mp3"), "Music 5min", 5 * 60),    # 5 min (fills gap)
        ]
        
        result = splitter.split_into_discs_filling_gaps(tracks)
        
        # Disc 1 should have: 50 + 25 + 5 = 80 min
        self.assertEqual(len(result[0].tracks), 3)
        self.assertAlmostEqual(result[0].total_seconds, 80 * 60, delta=1)
        
        # Disc 2 should have: 40 min
        self.assertEqual(len(result[1].tracks), 1)
        self.assertEqual(result[1].tracks[0].title, "Music 40min")

    @patch('sys.stdout', new_callable=io.StringIO)
    def test_smart_fill_oversized_track_first(self, mock_stdout):
        """Test smart fill isolates oversized track at the beginning."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [
            Track(Path("t1.mp3"), "Giant", 90 * 60),     # Exceeds capacity
            Track(Path("t2.mp3"), "Normal", 30 * 60),
        ]
        
        result = splitter.split_into_discs_filling_gaps(tracks)
        output = mock_stdout.getvalue()
        
        self.assertIn("WARNING: Track 'Giant'", output)
        self.assertIn("exceeds disc capacity! Will be isolated", output)
        self.assertEqual(len(result), 2)
        self.assertEqual(len(result[0].tracks), 1)  # Giant track isolated
        self.assertEqual(result[0].tracks[0].title, "Giant")

    @patch('sys.stdout', new_callable=io.StringIO)
    def test_smart_fill_multiple_oversized_tracks(self, mock_stdout):
        """Test smart fill handles multiple oversized tracks."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [
            Track(Path("t1.mp3"), "Giant1", 90 * 60),
            Track(Path("t2.mp3"), "Giant2", 85 * 60),
            Track(Path("t3.mp3"), "Normal", 30 * 60),
        ]
        
        result = splitter.split_into_discs_filling_gaps(tracks)
        output = mock_stdout.getvalue()
        
        self.assertEqual(len(result), 3)
        self.assertEqual(result[0].tracks[0].title, "Giant1")
        self.assertEqual(result[1].tracks[0].title, "Giant2")
        self.assertEqual(result[2].tracks[0].title, "Normal")

    def test_smart_fill_optimal_packing(self):
        """Test smart fill achieves better packing than greedy."""
        splitter = Splitter(capacity_minutes=100)
        tracks = [
            Track(Path("t1.mp3"), "Track 1", 60 * 60),   # 60 min
            Track(Path("t2.mp3"), "Track 2", 50 * 60),   # 50 min
            Track(Path("t3.mp3"), "Track 3", 40 * 60),   # 40 min
            Track(Path("t4.mp3"), "Track 4", 10 * 60),   # 10 min
        ]
        
        result = splitter.split_into_discs_filling_gaps(tracks)
        
        # Smart fill should pack: [60, 40] and [50, 10] = 2 discs
        # Greedy would pack: [60], [50, 40], [10] = 3 discs
        self.assertEqual(len(result), 2)

    def test_smart_fill_disc_ids_sequential(self):
        """Test that disc IDs are sequential in smart fill."""
        splitter = Splitter(capacity_minutes=40)
        tracks = [Track(Path(f"t{i}.mp3"), f"Track {i}", 30 * 60) for i in range(5)]
        
        result = splitter.split_into_discs_filling_gaps(tracks)
        
        for i, disc in enumerate(result, start=1):
            self.assertEqual(disc.id, i)

    def test_smart_fill_all_tracks_used(self):
        """Test that smart fill uses all tracks."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [
            Track(Path(f"t{i}.mp3"), f"Track {i}", 20 * 60) 
            for i in range(10)
        ]
        
        result = splitter.split_into_discs_filling_gaps(tracks)
        
        total_tracks = sum(len(disc.tracks) for disc in result)
        self.assertEqual(total_tracks, 10)

    def test_smart_fill_complex_scenario(self):
        """Test smart fill with complex real-world scenario."""
        splitter = Splitter(capacity_minutes=79.5)
        
        # Simulate a realistic mix of track lengths
        tracks = [
            Track(Path("t1.mp3"), "Epic Song", 45 * 60),      # 45 min
            Track(Path("t2.mp3"), "Long Track", 35 * 60),     # 35 min
            Track(Path("t3.mp3"), "Medium 1", 25 * 60),       # 25 min
            Track(Path("t4.mp3"), "Medium 2", 20 * 60),       # 20 min
            Track(Path("t5.mp3"), "Short 1", 10 * 60),        # 10 min
            Track(Path("t6.mp3"), "Short 2", 5 * 60),         # 5 min
            Track(Path("t7.mp3"), "Short 3", 8 * 60),         # 8 min
        ]
        
        result = splitter.split_into_discs_filling_gaps(tracks)
        
        # Verify all discs are within capacity
        for disc in result:
            self.assertLessEqual(disc.total_seconds, 79.5 * 60)
        
        # Verify all tracks are included
        total_tracks = sum(len(disc.tracks) for disc in result)
        self.assertEqual(total_tracks, 7)


class TestEdgeCases(unittest.TestCase):
    """Test suite for edge cases and boundary conditions."""

    def test_single_track_equals_capacity(self):
        """Test track with duration exactly equal to capacity."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [Track(Path("t1.mp3"), "Exact", 80 * 60)]
        
        result = splitter.split_into_discs(tracks)
        
        self.assertEqual(len(result), 1)
        self.assertEqual(len(result[0].tracks), 1)

    def test_very_small_tracks(self):
        """Test handling of very small duration tracks."""
        splitter = Splitter(capacity_minutes=80)
        tracks = [Track(Path(f"t{i}.mp3"), f"Track {i}", 0.1) for i in range(100)]
        
        result = splitter.split_into_discs(tracks)
        
        total_tracks = sum(len(disc.tracks) for disc in result)
        self.assertEqual(total_tracks, 100)

    def test_very_large_capacity(self):
        """Test with very large disc capacity."""
        splitter = Splitter(capacity_minutes=500)
        tracks = [Track(Path(f"t{i}.mp3"), f"Track {i}", 30 * 60) for i in range(10)]
        
        result = splitter.split_into_discs(tracks)
        
        # All tracks should fit on one disc
        self.assertEqual(len(result), 1)
        self.assertEqual(len(result[0].tracks), 10)

    def test_very_small_capacity(self):
        """Test with very small disc capacity."""
        splitter = Splitter(capacity_minutes=1)
        tracks = [Track(Path(f"t{i}.mp3"), f"Track {i}", 30) for i in range(5)]
        
        result = splitter.split_into_discs(tracks)
        
        # Tracks are 30 seconds each, capacity is 60 seconds (1 min)
        # So 2 tracks per disc: [0,1], [2,3], [4]
        self.assertEqual(len(result), 3)
        self.assertEqual(len(result[0].tracks), 2)
        self.assertEqual(len(result[1].tracks), 2)
        self.assertEqual(len(result[2].tracks), 1)


if __name__ == '__main__':
    unittest.main()